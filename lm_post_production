#!/bin/bash

# This script converts all your "article.txt" files to html-format.
# for this, you have to put all your articles in one subfolder and start this script from there
# Then it converts all listings
# TODO Sanity Checks

# Filenames
article=article.txt
error_log=error.log
article_html=article.html
satzfertig=sf
iconv=/usr/bin/iconv

# Path Variables
working_dir=$(pwd)
bin_dir="/opt/lnm/bin"
exportpath=${working_dir}"/../../1_export"
target_folder=${working_dir}"/../../2_checked"
editor=/usr/bin/gedit
browser=/usr/bin/firefox

# Magazine Issue
issue_year=$(pwd | grep -o "[2][0][0-9][0-9]")
issue_month=$(pwd | grep -o "[2][0][0-9][0-9]..." | tail -c 3)

## Convert article.txt to UTF-8 otherwise script breaks
 
function convert_to_utf8 {
    
    ${iconv} -f ISO-8859-15 -t UTF-8 ${article} -o ${article}
}


## Convert article.txt back to ISO-8859-15

function convert_to_iso8859_15 {
    
    ${iconv} -f UTF-8 -t ISO-8859-15 ${article} -o ${article}
}


##  Module: DISPLAY HELPFILE FOR THE PROGRAM ##

function get_help {
    
    bold=`tput bold`
    normal=`tput sgr0`

    echo -e "${bold}NAME${normal}"
    echo -e "\tlm_post_production.sh\n"

    echo -e "${bold}SYNOPSIS${normal}"
    echo -e "\tlm_post_production.sh --help | --dryrun | --convert | --xml\n"

    echo -e "${bold}DESCRIPTION${normal}"
    echo -e "\tPut this script in your own folder in '1_export'. It converts 
    \t'.txt' into '.html' files, logs error messages in 'error.log'. And
    \t it can generates XML files.\n"

    echo -e "\tIts submodules in 'modules/' remove unwanted artefacts.
    \tFor every article the script displays the converted '.html' file in 
    \tin Firefox (-d). If that looks alright the script will extract all
    \tlistings and move the whole folder including the listings to
    \t'2_checked' (-c). Finally it generates XML files and repairs some
    \tdetails in those (-x).\n"

    echo -e "${bold}OPTIONS${normal}"
    echo -e "\t-h / --help"
    echo -e "\t\tDisplay this help.\n"
    echo -e "\t-d / --dryrun"
    echo -e "\t\tStarts a testrun that only collects 'sf'-errors in 'error.log'\n"
    echo -e "\t-c / --convert"
    echo -e "\t\tRun this script and convert files.\n"
    echo -e "\t-x / --xml"
    echo -e "\t\tConverts HTML to XML files. Shows errors and prepares XML for upload.\n"

    echo -e "${bold}AUTHOR${normal}"
    echo -e "\tWritten by Kristian Kißling\n"

    echo -e "${bold}REPORTING BUGS${normal}"
    echo -e "\tBug Reports to kkissling@linux-magazin.de\n"

    echo -e "${bold}COPYRIGHT${normal}"
    echo -e "\tLicense: GNU Public License v2."
    echo -e "\tThis is free software: you are free  to  change  and  redistribute  it.
    \tThere is NO WARRANTY, to the extent permitted by law."
}

##  Module: REMOVE ALL COMMENTS EXCEPT THE ONE WITH ID ##

function mod_remove_comments {

# Deletes every comment except that @#:ID:...
# '/Delete this/ {/Apart from that/! d}'
occurence=$(grep -c '^@#' ${article})

    if [ "${occurence}" -gt "2" ]; then
        
        sed -i '/^@#.*$/ {/^@#:ID.*$/! d}' ${article}
    fi    
}

##  Module: REMOVE UNWANTED BOXES (INHALT, DELUG) ##

function mod_remove_boxes_check {
startbox=$(grep -n -e "^@KT: *Inhalt\|@KT: *D[eE][lL][uU][gG]\|@KT: *H[Ee][fF][tT]-DVD" ${article} | cut -d ":" -f1 | head -n 1)
}

function mod_remove_boxes {
    mod_remove_boxes_check
    while [ "${startbox}" ]
    do
        endbox=$(grep -n -e "^@KE" ${article} | cut -d ":" -f1)
        for j in ${endbox}; do
            if [ "${j}" -gt "${startbox}" ]; then
                echo -e "\n8<----------"
                sed ${startbox},${j}'!d' ${article} | tr "[:space:]" " "
                echo -e "\n---------->8\n"
                read -p "This textbox is not needed anymore. Delete? [y/n]" delete
                case ${delete} in
                    y)
                        sed -i ${startbox},${j}'d' ${article}
                        echo "Box deleted."
                        mod_remove_boxes_check
                        if [ ${startbox} ]; then
                            continue
                        else
                            break
                        fi
                        ;;
                    n)
                        echo "Please remove unneeded boxes by hand."
                        break 2
                        ;;
                    *)
                        echo "Please type only [y] or [n]."
                        ;;
                esac
            else
                continue
            fi
        done
    done
}


##  Module: REMOVE DUPLICATE TITLE PICTURES ##
#   removes duplicate title pics in "sw_einf"

function mod_remove_duplicate {

keyword=$(grep -e '@SW:*Einf.hrung' ${article})
category=$(grep -e '@R:*Software' ${article})
dupimage=$(grep -c 'DVDgold' ${article})
secimage=$(grep -e 'DVDgold' ${article} | tail -1)

    if { [ ${keyword} ] && [ ${category} ] ;} && [ ${dupimage} == 2 ]; then
        
        # use "|" instead of "/" als delimiter because of path in secimage
        sed -i "s|$secimage||g" ${article}
    fi
}

## Module: Control Box Title in News ##

function mod_repair_news_box {

news=$(grep -e '@SW: *News' ${article})
boxtitle=$(grep -e '^@KT: *Kurznachrichten*$' ${article})

if [ "${news}" ] ; then
    if [ -z "${boxtitle}" ]; then
        startbox=$(grep -n '^@KL: *.*$' ${article} | head -n 1 | cut -d ":" -f1)
        entrypoint=$((${startbox}-1))
        sed -i ''"${entrypoint}"'i@KT: Kurznachrichten' ${article}
    fi
fi
}


##  Module: REMOVE DOUBLE LINES WITH EMPTY TABS ##

function mod_remove_tablines {

# Grep only those lines that consist only in Tabs
# That prevents deleting lines with content
tabs=$(grep -n '^        [^[:alnum:]]*$' ${article} | cut -d ":" -f1)
    for i in ${tabs}; do
        Zeile erfassen
        checke ob Zeile drüber Tabzeile
        checke ob Zeile drunter Tabzeile
        wenn beides erfüllt, löschen
        wenn nicht beides erfüllt, nächste Zeile
    done
}


## Module: CHANGE PICTURES IN EDITORIAL ##

function mod_prepare_edi {
edi=$(grep -e '@R: *Editorial' ${article})

    if [ "${edi}" ]; then
        # remove empty tags
        sed -i '/@V:.*$/d' ${article}
        sed -i '/@A:.*$/d' ${article}
        
        # switch jans picture with his signature
        upper_img=$(grep -n "@BA\: *.*unterschrift.*$" ${article} | cut -d ":" -f 1)
        lower_img=$(grep -n "@B\: *.*Chefredakteur.*$" ${article} | cut -d ":" -f 1)
        lower_plus_one=$((${lower_img}+1))
        upper_plus_one=$((${upper_img}+1))

        if [[ "${upper_img}" ]] && [ "${lower_img}" -gt "${upper_img}" ]; then
            upper=$(grep "@BA: *.*" ${article})
            lower=$(grep "@BI: *.*" ${article})
            lower_bu=$(grep "@B: *.*" ${article})
            
            sed -i ''"${upper_img}"'c'"${lower}" ${article}
            sed -i ''"${lower_img}"'c'"${upper}" ${article}
            sed -i ''"${upper_plus_one}"'c'"${lower_bu}" ${article}
            artefakt=$(grep -n "@BI" ${article} | cut -d ":" -f 1 | tail -n -1)
            sed -i ''"${artefakt}"'d' ${article}

            sed -i 's|@BA|@BI|' ${article}
            sed -i '/unterschrift/!s/@BI/@BA/g' ${article}
        fi
    fi
}


## Module: REPLACE BOXES IN BOOK ARTICLE ##

function mod_replace_bookbox {

buecher=$(grep -e '@SW:*B.cher' ${article})
infobox=$(grep -c '^@IT:.*Info' ${article})

    if [ "${buecher}" ] && [ "${infobox}" == 2 ]; then
        
        sed -i '0,/IT\:.*fo$/s//KT:Info 1/; /IT\:.*fo$/s//KT:Info 2/' ${article}
        sed -i 's/@IL:/@KL:/g' ${article}
    fi
}


## Module: FILL OUT HEADER LINE IN LETTERS TO THE EDITOR ##

function mod_prepare_ed_letter {

leserbriefe=$(grep -e '@SW:*Leserbriefe' ${article})
dachzeile=$(grep -e '@D: *$' ${article})

if [ "${leserbriefe}" ] && [ "${dachzeile}" ]; then
    
    sed -i 's/@D:/@D:Auf den Punkt gebracht/g' ${article}
    sed -i 's/@T:/@T:Leserbriefe/g' ${article}
fi
}


## Module: CHANGE PIC ORDER IN NEWS AND ZUT ##
# Needed for XML Upload

function mod_prepare_pics_news_zut {

news=$(grep -e '@SW: *News' ${article})
zut=$(grep -e '@SW: *Zahlen & Trends' ${article})

if [ "${news}" ] || [ "${zut}" ] ; then
    
    # First remove empty @V: and @A:-Tags
    sed -i '/@V:.*$/d' ${article}
    sed -i '/@A:.*$/d' ${article}
    
    # Now switch lines for pictures
    countr=$(grep -c '^@BC:' ${article})
    for i in $(seq 1 ${countr}); do
        # look for first matches, if several matches, only show last one
        text=$(grep -o '@BC:.*$' -m ${i} ${article} | tail -n 1)
        # look for first matches with line numbers, if several, cut and only show last line number
        line=$(grep -n '@BC:' -m ${i} ${article} | cut -d ":" -f 1 | tail -n 1)
        # show number of line before
        line_before=$(($line-1))
        # remember content of line before
        text_before=$(grep -B 1 '@BC:.*$' -m ${i} ${article} | tail -n 2 | grep -o '@B:.*$')
        if [ "${text_before}" ]; then
            # now replace lines that start with @BC: with those that start with @B:
            sed -i ''"${line_before}"'c'"${text}"'' ${article}
            sed -i ''"${line}"'c'"${text_before}"'' ${article}
        else
            continue
        fi
    done
fi
}

## Module: PREPARE TOOLTIPPS ##

function mod_prepare_tooltipps {
tooltipps=$(grep -e '@T: *Tooltipps' ${article})

if [ "${tooltipps}" ]; then
    
    trailer=$(grep -e '@V: *$' ${article})
    author=$(grep -e '@A: *$' ${article})
    
    if [ "${trailer}" ]; then
        for i in $(grep -n '^@KT: *.*$' article.txt | cut -d ":" -f 1); do
            # Show text following @KT:
            headlines=$(sed ''"${i}"'!d' ${article} | cut -d ":" -f 2)
            # Keep @V-line (&) but $headline followed by a comma
            sed -i 's/\@V: *.*$/&'"${headlines}"', /g' ${article}
        done
            # Keep pattern part in parenthesis, remove last comma, add Text after @V
            sed -i 's/\@V:\( *.*\), $/\@V:Im Kurztest: \1 /' ${article}
    fi
    if [ "${author}" ]; then
        # add author
        sed -i 's/\@A: *.*$/\@A:Uwe Vollbracht/g' ${article}
    fi
    # remove wrong tagged @BA-picture
    sed -i '/@BA: *.*$/d' ${article}
    # replace @KT: with @ZKT:
    sed -i 's/@KT:/@ZKT:/g' ${article}
    # replace all BI-Tags except one
    sed -i '/Visual_Tooltipps/!s/@BI:/@C:/g' ${article}
fi
}

## Module: REMOVE WHITESPACES FROM URLs

function mod_repair_urls {

urls=$(grep -o "\(<U> *.*[[:space:]]*.*<U>\)" ${article} | grep "[[:space:]]" )
    
    if [ "${urls}" ]; then
        # 
        sed -i 's/\(<U>.*\) \(.*<U>\)/\1\2/g' ${article}
    fi
}


## Module: USE SATZFERTIG AND CHECK RESULT IN BROWSER ##

function mod_html_check {


# write sf stderr and stdout in error.log
echo -e "## Start of error.log for:" ${folder} "##\n" >> ../${error_log}
${bin_dir}/${satzfertig} -H ${article} ${article_html} >> ../${error_log} 2>&1 &&
echo -e "\n## End of error.log for:" ${folder} "##\n" >> ../${error_log}

# watch HTML File in $browser
while true
    do
        read -p "Check generated HTML in a browser? [y/n]" firefox
        case ${firefox} in
            y)
                ${browser} --safe-mode ${article_html} 2>&1
                break
                ;;
            *)
                break
                ;;
        esac
    done
}


## Module: EXTRACT LISTINGS FROM ARTICLES ##

function mod_extract_listing {

avail=$(grep "@KT: *Listing 1" ${article})

if [ "$avail" ]; then
    
    if [ -d listings ]; then
        rm -fR listings
    fi

    mkdir listings >/dev/null 2>&1
    chmod a+rw listings

    ${satzfertig} -nL listings ${article} > /dev/null 2>&1 &&

    cd listings
    for i in * ; do
        sed -i 's/\(.\{2\}\)//' ${i}
        j=$(ls ${i} | cut -c 13-)
        mv ${i} listing${j}
        sleep 2
    # TODO: Remove Inline-Text-Listings, keep only Listing Boxes
    done
    rm listing_* > /dev/null 2>&1
    cd ..
fi
}


## Module: MOVE FINISHED ARTICLES ##

function mod_move_finalized_folder {

	if [ -d ${target_folder} ]; then
	    #...if so, move all folders there
	    mv -i ${folder} ${target_folder}
	    echo "Move" ${folder} "to 2_checked."
	    echo -e "****\n"
	else
	    #...if not, mkdir folder
	    echo "Folder '2_checked' doesn't exist yet. Please add."
	    exit 0
	    # TODO: Folder anlegen: mkdir ../../2_checked
	fi
}


## Module: REPAIR XML ##

function mod_repair_xml {

article=article.xml

edi=$(grep -e '<section>Editorial</section>' ${article})
buecher=$(grep -e '<subject>Bücher</subject>' ${article})
perlsnap=$(grep -e '<subject>Perl-Snapshot</subject>' ${article})
delugdvd=$(grep -e '<kicker>In eigener Sache: DELUG-DVD</kicker>' ${article})

	if [ "${edi}" ] ; then
		sed -i 's/online access="free"/online access="restricted"/' ${article}
	    echo "Prepared XML file in ${folder} for Upload."
	fi

	if [ "${buecher}" ] || [ "${perlsnap}" ] || [ "${delugdvd}" ]; then
	    sed -i 's/online\ access="restricted"/online\ access="free"/' ${article}
	    echo "Prepared XML file in ${folder} for Upload."
	fi
}



#####   Main: "-d" - START A DRYRUN #####
#       Repairs all kinds of bugs before conversion and shows result

function dryrun {
    # check, if location is your own subfolder in "1_export", for example "kki"
    
    sleep 2
    if [ -d ${exportpath} ]; then

        # make error.log for sf if non-existing
        if [ ! -f ${working_dir}/${error_log} ]; then
            touch ${working_dir}/${error_log}
            chmod a+x ${working_dir}/${error_log}
        fi

        ## Insert modules
        # List folders with leading digits and dive into it
        for folder in $(ls -d [[:digit:]]*); do
            if [ -d ${working_dir}/${folder} ]; then
                cd ${working_dir}/${folder}
                echo -e "\nNext article:"${folder}
                echo -e "================================"
                # convert to UTF-8
                convert_to_utf8
                
                # this module removes "Heft-DVD" boxes that make no sense online
                mod_remove_duplicate
                mod_replace_bookbox
                mod_prepare_ed_letter
                mod_prepare_pics_news_zut
                mod_repair_news_box
                mod_prepare_edi
                mod_repair_urls
                mod_repair_editor_abbrevation
                mod_prepare_tooltipps
                mod_remove_comments
                mod_remove_boxes
                
                # convert back to ISO-8859-15
                convert_to_iso8859_15
                
                mod_html_check
                                
                while true
                    do
                    read -p "Do you want to change something on the article and/or take a look at the 'error.log' now? [y/n]" error
                        case ${error} in
                        y)                            
                            echo "Error Log:"
                            cat ${working_dir}/${error_log} | more
                            echo -e "\n"
                            echo "Starting Editor..." 
                            rm ${working_dir}/${error_log}
                            sleep 2
                            ${editor} ${article} &&
                            
                            read -p "Move on to the next article? [y/n]" moveon
                                case ${moveon} in
                                y)
                                    break
                                    ;;
                                *)
                                    exit 0
                                    ;;
                                esac
                            break
                            ;;
                        *)
                            read -p "Move on to the next article? [y/n]" moveover
                                case ${moveover} in
                                y)
                                    rm ${working_dir}/${error_log}
                                    break
                                    ;;
                                *)
                                    exit 0
                                    ;;
                                esac
                            break      
                            ;;
                        esac
                    done
                # go back in your subfolder, for example "kki"
                cd ..
            fi
        done
        echo -e "\nIf all articles look fine, you should now call 'lm_post_production -c' to extract listings and prepare files for a proper XML export.\n"
    else
	echo -e "You probably started this script from the wrong dir"
        exit 0
    fi
}


##### Main: "-c" - CONVERT LISTINGS AND MOVE FOLDERS #######

function convert {
    # check, if location is your own subfolder in "1_export", for example "kki"
    if [ -d ${exportpath} ]; then

        # make error.log for sf if non-existing
        if [ -f ${working_dir}/${error_log} ]; then
            touch ${working_dir}/${error_log}
            chmod a+x ${working_dir}/${error_log}
        fi

        ## Insert modules
        #
        # list folders and ls into it one by one
        echo -e "Script generates listings now if it finds some..."
        for folder in $(ls -d [[:digit:]]*); do
            if [ -d ${working_dir}/${folder} ]; then
                cd ${working_dir}/${folder}
                # after everything is fine with article.txt, start extracting the listings
                mod_extract_listing

                # go back in your subfolder, for example "kki"
                cd ..

                # check if $target_folder exists and move just finalized $folder there
                mod_move_finalized_folder
            fi
        done
    else
        echo "You need to create a subfolder in '1_export' and start this script from there."
        exit 0
    fi
}


# CONVERT TXT TO XML AND CHANGE XML FILES
function xml {
    # check, if location is in "2_checked"
    if [ -d ${target_folder} ]; then
        ## Insert modules
        if [ "ls -A ${target_folder}" ]; then
            # change into '2_checked'
            cd ${target_folder}
            
            # show all folders an start conversion
            ls -d [0-9][0-9][0-9]*
        
            read -p "Convert all listed articles to XML - and repair XML files afterwards? [y/n]" yesyoucan
                case ${yesyoucan} in
                y | j)
                    . ${bin_dir}/convert2xml.sh -y ${issue_year} -i ${issue_month} -m LM
                    echo "Converted all articles to XML-files."
                    ;;
                *)
                    exit 0
                    ;;
                esac
            
        # repair things before conversion starts
        # list folders in '2_checked' and ls into it one by one
            for folder in $(ls -d [0-9][0-9][0-9]*); do
                if [ -d ${target_folder}/${folder} ]; then 
                    cd ${target_folder}/${folder}
                    mod_repair_xml
                fi
            done
        else
            echo -e "No folder found in '2_checked'."
        fi
    else
        echo "This option only works if you call it from '1_export/<your_folder>'. It prepares existing XML files for the upload to our website."
        exit 0
    fi
}

function start {
    if [ "${1}" == "" ] || [ "${1}" == "-h" ] || [ "${1}" == "--help" ]; then
        get_help
    elif [ "${1}" == "-d" ] || [ "${1}" == "--dryrun" ]; then
        dryrun
    elif [ "${1}" == "-c" ] || [ "${1}" == "--convert" ]; then
        convert
    elif [ "${1}" == "-x" ] || [ "${1}" == "--xml" ]; then
        xml
    fi
}

start "${1}"
