#!/bin/bash

# This script converts all your "article.txt" files to html-format.
# for this, you have to put all your articles in one subfolder and start this
# script from there. Then it converts all listings

# Filenames
article=article.txt
error_log=error.log
article_html=article.html
satzfertig=sf
iconv=/usr/bin/iconv

# Path Variables
working_dir=$(pwd)
bin_dir="/opt/lnm/bin"
exportpath=${working_dir}"/../../1_export"
target_folder=${working_dir}"/../../2_checked"
editor=/usr/bin/gedit
browser=/usr/bin/firefox

# Magazine Issue
issue_year=$(pwd | grep -o "[2][0][0-9][0-9]")
issue_month=$(pwd | grep -o "[2][0][0-9][0-9]..." | tail -c 3)

## Convert article.txt to UTF-8 otherwise script breaks

function convert_to_utf8 {

if [ -e article.txt ]; then
    chmod 755 ${article}
    ${iconv} -f ISO-8859-15 -t UTF-8 ${article} -o article.txt.tmp
    wait
    mv article.txt.tmp article.txt
    wait
else
	echo -e "File article.txt doesn't seem to exist."
	exit 0
fi
}


## Convert article.txt back to ISO-8859-15

function convert_to_iso8859_15 {

if [ -e article.txt ]; then
    chmod 755 ${article}
    ${iconv} -f UTF-8 -t ISO-8859-15 ${article} -o article.txt.tmp
    wait
    mv article.txt.tmp article.txt
    wait
else
    echo -e "File article.txt doesn't seem to exist."
	exit 0
fi
}


##  Module: DISPLAY HELPFILE FOR THE PROGRAM ##

function get_help {

    bold=`tput bold`
    normal=`tput sgr0`

    echo -e "${bold}NAME${normal}"
    echo -e "\tlm_post_production.sh\n"

    echo -e "${bold}SYNOPSIS${normal}"
    echo -e "\tlm_post_production.sh --help | --check | --repair | --make_listings | --upload\n"

    echo -e "${bold}DESCRIPTION${normal}"
    echo -e "\tPut this script in your own folder in '1_export'. It converts
    \t'.txt' into '.html' files, logs error messages in 'error.log'. And
    \t it generates XML files for upload via sf2xml.\n"

    echo -e "\tFor every article the script checks (-c), if the Indesign Export
    \tworked out and there exists a file 'article.txt' in every folder. The user only
    \t has to start the script with this option once, in the beginning of the process.
    \tWith the Repair-Switch (-r) the script displays the repaired and converted
    \t'.html' file in Firefox. If that looks alright the script will
    \textract all listings and move them to the ftp-server (-m). Then it moves
    \tthe whole folder including the listings to '2_checked'. Finally (-u)
    \tit generates XML files and repairs some details of it to
    \tmake the article ready for upload.\n"

    echo -e "${bold}OPTIONS${normal}"
    echo -e "\t-h / --help"
    echo -e "\t\tDisplay this help.\n"
    echo -e "\t-c / --check"
    echo -e "\t\tCheck if 'article.txt' files are in place (only once)\n"
    echo -e "\t-r / --repair"
    echo -e "\t\tCollects 'sf'-errors in 'error.log' and repairs Bugs from export\n"
    echo -e "\t-m / --make_listings"
    echo -e "\t\tConverts and uploads listings. Moves folders to '2_checked'.\n"
    echo -e "\t-u / --upload"
    echo -e "\t\tConverts HTML to XML files and those for upload.\n"

    echo -e "${bold}AUTHOR${normal}"
    echo -e "\tWritten by Kristian Kißling, 2015 - 2016\n"

    echo -e "${bold}REPORTING BUGS${normal}"
    echo -e "\tBug Reports to kkissling@linux-magazin.de\n"

    echo -e "${bold}COPYRIGHT${normal}"
    echo -e "\tLicense: GNU Public License v2."
    echo -e "\tThis is free software: you are free  to  change  and  redistribute  it.
    \tThere is NO WARRANTY, to the extent permitted by law."
}

## Module: WARNS WHERE MANUAL CHANGES ARE NECESSARY
# Warnings could be removed with future solutions

function mod_warnings {

# warns, if unwanted elements are found inside a box
warning_a1=$(grep -o '^@[A-Z]*:' ${article} | grep -B1 '@KE' | grep -n '@L:')
warning_a2=$(grep -o '^@[A-Z]*:' ${article} | grep -B1 '@KE' | grep -n '@BI:')
warning_a3=$(grep -o '^@[A-Z]*:' ${article} | grep -B1 '@KE' | grep -n '@B:')
warning_a4=$(grep -o '^@[A-Z]*:' ${article} | grep -B1 '@KE' | grep -n '@TT:')

    if [ "${warning_a1}" ] || [ "${warning_a2}" ] || [ "${warning_a3}" ] || [ "${warning_a4}" ]; then
        rot=$(tput setaf 1)
        reset=$(tput sgr0)
        echo -e ${rot}"Pictures or Tables seem to be inside a box in " ${folder} ". PLEASE CORRECT BY HAND." ${reset}
    fi

# warns, that pictures and news items are probably paired wrong
news=$(grep -e '@SW: *News' ${article})
zut=$(grep -e '@SW: *Zahlen & Trends' ${article})

	if [ "${news}" ] || [ "${zut}" ] ; then
		rot=$(tput setaf 1)
		reset=$(tput sgr0)
		echo -e ${rot}"Please check if pictures stick to text in " ${folder}" and CORRECT BY HAND."${reset}
	fi

# warns of wrong picture order or missing pics
pic_order=$(grep -o "^@B: *Abbildung [0-9]*" ${article} | cut -d ":" -f2)

if [ "${pic_order}" ]; then
    pic_counts=()
    pic_counts+=$(grep -c '^@B: *Abbildung [0-9]*' ${article})

    for i in $(seq 1 ${pic_counts[@]}); do
        assumed_order="Abbildung "${i}
        actual_order=$(grep -o "^@B: *Abbildung [0-9]*" ${article} | cut -d ":" -f2 | sed -n "${i}p")
        if [ "${assumed_order}" == "${actual_order}" ]; then
            continue
        else
            rot=$(tput setaf 1)
            reset=$(tput sgr0)
            echo -e ${rot}"Picture order seems to be wrong or a picture is missing in" ${folder}"."${reset}
            break
        fi
    done
fi

# warns of wrong listing order or missing listings
listing_order=$(grep -o "^@KT: *Listing [0-9]*" ${article} | cut -d ":" -f2)

if [ "${listing_order}" ]; then
    listing_counts=()
    listing_counts+=$(grep -c '^@KT: *Listing [0-9]*' ${article})

    for i in $(seq 1 ${listing_counts[@]}); do
        assumed_listing_order="Listing "${i}
        actual_listing_order=$(grep -o "^@KT: *Listing [0-9]*" ${article} | cut -d ":" -f2 | sed -n "${i}p")
        if [ "${assumed_listing_order}" == "${actual_listing_order}" ]; then
            continue
        else
            rot=$(tput setaf 1)
            reset=$(tput sgr0)
            echo -e ${rot}"Listing order seems to be wrong or a listing is missing in" ${folder}"."${reset}
            break
        fi
    done
fi
}


##  Module: REMOVE ALL COMMENTS EXCEPT THE ONE WITH ID ##

function mod_repair_comments {

# Deletes every comment except that @#:ID:...
# Shows a message if no ID at all is found
# '/Delete this/ {/Apart from that/! d}'
occurence=$(grep -c '^@#' ${article})
occurence_id=$(grep -c '^@#: *ID: *[0-9]' ${article})

    if [ "${occurence}" -gt "1" ]; then
        sed -i '/^@#.*$/ {/^@#:ID.*$/! d}' ${article}
    fi

    if [ "${occurence_id}" -lt "1" ]; then
		rot=$(tput setaf 1)
        reset=$(tput sgr0)
        echo -e ${rot}"The @#:ID in" ${folder} "seems to be lacking, please correct." ${reset}
    fi
}

function mod_insecurity_pic {

# remove standard-pic from Insec if there are two pics or more
#insec=$(grep -e '@SW: *Insecurity' ${article})
vis=$(grep -n '@BA:.*Visual_insecurity' ${article} | cut -d ":" -f 1)
titlepic=$(grep -e '@BI:.*123[rR][fF].*' ${article})
artefakt=$(grep -n '@BI:.*123[rR][fF].*' ${article} | cut -d ":" -f 1 | tail -n -1)

    if [[ "${vis}" ]] && [[ "${titlepic}" ]]; then
	sed -i ''"${vis}"'c'"${titlepic}" ${article}
	artefakt=$(grep -n '@BI:.*123[rR][fF].*' ${article} | cut -d ":" -f 1 | tail -n -1)
	sed -i ''"${artefakt}"'d' ${article}
    fi
}

# deletes needless Ads and cover pictures

function mod_remove_ads {

ads=$(grep -e '@B.: *.*_ANZ_' ${article})

	if [ "${ads}" ] ; then
		ads_cp_right=$(grep -n -e '@BA:' ${article} | cut -d ":" -f 1)
		if [ "${ads_cp_right}" ]; then
			ba=$((${ads_cp_right}+1))
			sed -i ''"${ba}"'d' ${article}
		fi
        sed -i 's/@B.: *.*_ANZ_.*$//g' ${article}
	fi
}


## Module: REMOVE UNWANTED BOXES

function mod_find_broken_boxes {

	endbox=$(grep -n -e "^@KE" ${article} | cut -d ":" -f1)
	for k in ${endbox}; do
		if [ "${k}" -gt "${j}" ]; then
			echo -e "\n8<----------"
            sed -e "${j}","${k}"'!d' ${article} | tr -s "[:space:]" " " | tr '@' '\n'
            echo -e "\n---------->8\n"
            read -p "Should I delete this textbox? [y/n]" delete
			case ${delete} in
                    y)
                        sed -i "${j}","${k}"'d' ${article}
                        counter=$((${counter} + 1))
                        echo "Box deleted."

                        if [[ ${counter} -le ${occurences} ]]; then
							mod_remove_boxes
						else
							break 2
						fi
                        ;;
                    n)
						counter=$((${counter} + 1))
                        break
                        ;;
			esac
			break
		fi
	done
}

function mod_remove_boxes {

	startbox=$(grep -n -e "^@KT: *Inhalt\|^@KT: *D[eE][lL][uU][gG]\|^@KT: *H[Ee][fF][tT]-DVD" ${article} | cut -d ":" -f1)
	occurences=$(grep -c -e "^@KT: *Inhalt\|^@KT: *D[eE][lL][uU][gG]\|^@KT: *H[Ee][fF][tT]-DVD" ${article})

	if [[ "${startbox}" ]]; then
			for j in ${startbox}; do
				mod_find_broken_boxes
			done
	fi
}

##  Module: REMOVE DUPLICATE TITLE PICTURES ##
#   removes duplicate title pics in "sw_einf"

function mod_remove_duplicate {

keyword=$(grep -e '@SW:*Einf.hrung' ${article})
category=$(grep -e '@R:*Software' ${article})
dupimage=$(grep -c 'DVDgold' ${article})
secimage=$(grep -e 'DVDgold' ${article} | tail -1)

    if { [ ${keyword} ] && [ ${category} ] ;} && [ ${dupimage} == 2 ]; then

        # use "|" instead of "/" als delimiter because of path in secimage
        sed -i "s|$secimage||g" ${article}
    fi
}

## Module: Control Box Title in News ##

function mod_repair_news_box {

news=$(grep -e '@SW: *News' ${article})
boxtitle=$(grep -e '^@KT: *Kurznachrichten*$' ${article})

if [ "${news}" ] ; then
    if [ -z "${boxtitle}" ]; then
        startbox=$(grep -n '^@KL: *.*$' ${article} | head -n 1 | cut -d ":" -f1)
        entrypoint=$((${startbox}-1))
        # i in i@KT stands for "insert at line xyz"
        sed -i ''"${entrypoint}"'i@KT: Kurznachrichten' ${article}
    fi
fi
}

##  Module: FILL DACHZEILE IN ZUT ##

function mod_repair_news_headline {

zut=$(grep -e '@SW: *Zahlen & Trends' ${article})
news=$(grep -e '@SW: *News' ${article})

	if [ "${zut}" ]; then
		sed -i 's/@D: *.*$/@D:Zahlen \& Trends/g' ${article}
	fi

	if [ "${news}" ] ; then
		sed -i 's/@D: *.*$/@D:News/g' ${article}
	fi
}


##  Module: REMOVE DOUBLE LINES WITH EMPTY TABS ##

function mod_remove_tablines {

# Grep only those lines that consist only in Tabs
# That prevents deleting lines with content
tabs=$(grep -n '^        [^[:alnum:]]*$' ${article} | cut -d ":" -f1)
    for i in ${tabs}; do
        Zeile erfassen
        checke ob Zeile drüber Tabzeile
        checke ob Zeile drunter Tabzeile
        wenn beides erfüllt, löschen
        wenn nicht beides erfüllt, nächste Zeile
    done
}


## Module: CHANGE PICTURES IN EDITORIAL ##

function mod_prepare_edi {

edi=$(grep -e '@R: *Editorial' ${article})

    if [ "${edi}" ]; then
        # remove empty tags
        sed -i '/@V:.*$/d' ${article}
        sed -i '/@A:.*$/d' ${article}

        # switch jans picture with his signature
        upper_img=$(grep -n "@BA\: *.*unterschrift.*$" ${article} | cut -d ":" -f 1)
        lower_img=$(grep -n "@B\: *.*Chefredakteur.*$" ${article} | cut -d ":" -f 1)
        lower_plus_one=$((${lower_img}+1))
        upper_plus_one=$((${upper_img}+1))

        if [[ "${upper_img}" ]] && [ "${lower_img}" -gt "${upper_img}" ]; then
            upper=$(grep "@BA: *.*" ${article})
            lower=$(grep "@BI: *.*" ${article})
            lower_bu=$(grep "@B: *.*" ${article})

            sed -i ''"${upper_img}"'c'"${lower}" ${article}
            sed -i ''"${lower_img}"'c'"${upper}" ${article}
            sed -i ''"${upper_plus_one}"'c'"${lower_bu}" ${article}
            artefakt=$(grep -n "@BI" ${article} | cut -d ":" -f 1 | tail -n -1)
            sed -i ''"${artefakt}"'d' ${article}

            sed -i 's|@BA|@BI|' ${article}
            sed -i '/unterschrift/!s/@BI/@BA/g' ${article}
        fi
    fi
}


## Module: REPLACE BOXES IN BOOK ARTICLE ##

function mod_replace_bookbox {

buecher=$(grep -e '@SW:*B.cher' ${article})
infobox=$(grep -c '^@IT:.*Info' ${article})

    if [ "${buecher}" ] && [ "${infobox}" == 2 ]; then

        sed -i '0,/IT\:.*fo$/s//KT:Info 1/; /IT\:.*fo$/s//KT:Info 2/' ${article}
        sed -i 's/@IL:/@KL:/g' ${article}
    fi
}


## Module: FILL OUT HEADER LINE IN LETTERS TO THE EDITOR ##

function mod_prepare_ed_letter {

leserbriefe=$(grep -e '@SW:*Leserbriefe' ${article})
dachzeile=$(grep -e '@D: *$' ${article})

if [ "${leserbriefe}" ] && [ "${dachzeile}" ]; then

    sed -i 's/@D:/@D:Auf den Punkt gebracht/g' ${article}
    sed -i 's/@T:/@T:Leserbriefe/g' ${article}
fi
}


## Module: CHANGE PIC ORDER IN NEWS AND ZUT ##
# Needed for XML Upload

function mod_prepare_pics_news_zut {

news=$(grep -e '@SW: *News' ${article})
zut=$(grep -e '@SW: *Zahlen & Trends' ${article})

if [ "${news}" ] || [ "${zut}" ] ; then

    # First remove empty @V: and @A:-Tags
    sed -i '/@V:.*$/d' ${article}
    sed -i '/@A:.*$/d' ${article}

    # Now switch lines for pictures
    countr=$(grep -c '^@BC:' ${article})
    for i in $(seq 1 ${countr}); do
        # look for first matches, if several matches, only show last one
        text=$(grep -o '@BC:.*$' -m ${i} ${article} | tail -n 1)
        # look for first matches with line numbers, if several, cut and only show last line number
        line=$(grep -n '@BC:' -m ${i} ${article} | cut -d ":" -f 1 | tail -n 1)
        # show number of line before
        line_before=$(($line-1))
        # remember content of line before
        text_before=$(grep -B 1 '@BC:.*$' -m ${i} ${article} | tail -n 2 | grep -o '@B:.*$')
        if [ "${text_before}" ]; then
            # now replace lines that start with @BC: with those that start with @B:
            sed -i ''"${line_before}"'c'"${text}"'' ${article}
            sed -i ''"${line}"'c'"${text_before}"'' ${article}
        else
            continue
        fi
    done
fi
}


## Module: PREPARE TOOLTIPPS ##

function mod_prepare_tooltipps {

tooltipps=$(grep -e '@T: *Tooltipps' ${article})

if [ "${tooltipps}" ]; then
    trailer=$(grep -e '@V: *$' ${article})
    author=$(grep -e '@A: *$' ${article})

    #find out line number of alone standing pic
	single_pic=$(grep -n -A2 '@BI' ${article} | grep '@KT' | tail -n1 | cut -d "-" -f1)
        if [ "${single_pic}" ]; then
            single_pic_position=$((${single_pic}-2))

            #find out box with lacking pic
            box=$(grep -n -B3 '@KE' ${article} | grep -n '@KL' | cut -d ":" -f2 | grep -o '[0-9]*')
            box_insert=$((${box}+2))

            # insert pic in box
            pic=$(sed -n "${single_pic_position}"'p' ${article})
            sed -i ''"${box_insert}"'i'"${pic}"'' ${article}
            single_pic_position=$((${single_pic_position}+1))
            sed -i "${single_pic_position}"'d' ${article}
        fi
    if [ "${trailer}" ]; then
        for i in $(grep -n '^@KT: *.*$' ${article} | cut -d ":" -f 1); do
            # Show text following @KT:
            headlines=$(sed ''"${i}"'!d' ${article} | cut -d ":" -f 2)
            # Keep @V-line (&) but $headline followed by a comma
            sed -i 's/\@V: *.*$/&'"${headlines}"', /g' ${article}
        done
            # Keep pattern part in parenthesis, remove last comma, add Text after @V
            sed -i 's/\@V:\( *.*\), $/\@V:Im Kurztest: \1 /' ${article}
    fi
    if [ "${author}" ]; then
        # add author
        sed -i 's/\@A: *.*$/\@A:Uwe Vollbracht/g' ${article}
    fi
    # remove wrong tagged @BA-picture
    sed -i '/@BA: *.*$/d' ${article}
    # replace @KT: with @ZKT:
    sed -i 's/@KT:/@ZKT:/g' ${article}
    # replace all BI-Tags except one
    #sed -i '/Visual_Tooltipps/!s/@BI:/@C:/g' ${article}
fi
}



## Module: Import stars in Tooltipps

function mod_tooltipps_stars {

tooltipps_stars=$(grep -e '@T: *Tooltipps' ${article})
tooltipps_pass=$(grep -e '<R>' ${article})

if [ "${tooltipps_stars}" ] && [ ! "${tooltipps_pass}" ]; then

    back=$(pwd)
    cd ../../../../../../
    tt_one=$(ls | grep -e '_txt')
    tt_two=$(ls | grep -e 'tooltipp')
	occ=0

    if [[ -d ${tt_one} ]]; then
        cd ${tt_one}
        find_tt=$(find . -type d -name "*tooltipp*" -print)
        cd ${find_tt}
        forth=$(pwd)
        count_tt=$(grep -e '@T: *Tooltipps' *.txt | cut -d ":" -f 1)
            if [[ ${count_tt} ]]; then
                work=$(grep -o '<R>.*<R>' ${count_tt})
                for i in ${work}; do
                    i_new=$(echo ${i} | sed 's/\(\/\)/\\\1/')
					cd ${back}
					occ=$((${occ} + 1))
					sed -i '0,/@KE:/s/@KE:/'"${occ}"'KE:/' ${article}
					sed -i 's/\('"${occ}"'KE.*$\)/\n\1\n'"${i_new}"'/' ${article}
					#sed -i '/'"${i_new}"'/i \'"${occ}"'KE:' ${article}
					cd ${forth}
                done
            fi
        cd ${back}
		sed -i 's/[0-9]KE:/@KE:/' ${article}
    else
        cd ${back}
    fi
fi
}



## Module: REMOVE WHITESPACES, SQUARE BRACKETS FROM URLs

function mod_repair_urls {

urls_space=$(grep -o "\(<U> *.*[[:space:]]*.*<U>\)" ${article} | grep "[[:space:]]")

    if [ "${urls_space}" ]; then
        sed -i 's/\(<U>.*\) \(.*<U>\)/\1\2/g' ${article}
    fi

urls_brkt=$(grep -o "\(<U> *.*<U>]\)\|\(http:/<U>\)\|\(<U> *.*]\)\|\(]<U>[[:graph:]]\)" ${article})
	if [ "${urls_brkt}" ]; then
		#sed -i 's/\(\/<U>\)/\/\//g; s/\(<U>]\)/<U>/g; s/\(]<U>\)/<U> /g' ${article}
		rot=$(tput setaf 1)
        reset=$(tput sgr0)
        echo -e ${rot}"The URLs in" ${folder} "seem to be messed up, please check that." ${reset}
	fi
}


## Module: USE SATZFERTIG AND CHECK RESULT IN BROWSER ##

function mod_html_check {

# write sf stderr and stdout in error.log
echo -e "## Start of error.log for:" ${folder} "##\n" >> ../${error_log}
${bin_dir}/${satzfertig} -H ${article} ${article_html} >> ../${error_log} 2>&1 &&
echo -e "\n## End of error.log for:" ${folder} "##\n" >> ../${error_log}

# watch HTML File in $browser
while true
    do
        read -p "Check generated HTML in a browser? [y/n]" firefox
        case ${firefox} in
            y)
                ${browser} --safe-mode ${article_html} 2>&1
                break
                ;;
            *)
                break
                ;;
        esac
    done
}


## Module: ERASE EMPTY SPACES IN EDITORS ABBREVATION

function mod_repair_editor_abbrevation {

abbrevation=$(grep -n "\((<I>[[:space:]]*.*[[:space:]]<I>)\)" ${article} | grep "[[:space:]]")
matches=$(grep -o "\((<I>[[:space:]]*.*[[:space:]]<I>)\)" ${article} | grep -c "[[:space:]]" | cut -d ":" -f1 | tail -n -1)

    if [ "${abbrevation}" ]; then
        if [ "${matches}" == 1 ]; then
            sed -i 's/\(<I>.*\) \(.*<I>\)/\1\2/g' ${article}
        else
            echo "Several <I>-tagged matches with whitespaces. Please correct."
        fi
    fi
}


## Module: REPAIR PERL VIDEO BOX

function mod_repair_perl_video_box {

online=$(grep -o "<U><U>.*$" ${article})

    if [ "${online}" ]; then
            sed -i 's/<U><U>.*\(http.*plus\).*<U>/<U>\1<U>/g' ${article}
    fi
}

## Module: EXTRACT LISTINGS FROM ARTICLES ##

function mod_extract_listing {

avail=$(grep "@KT: *Listing 1" ${article})

if [ "$avail" ]; then

    if [ -d listings ]; then
        rm -fR listings
    fi

    mkdir listings >/dev/null 2>&1
    chmod a+rw listings

    ${satzfertig} -nL listings ${article} > /dev/null 2>&1 &&

    cd listings
    for i in * ; do
        sed -i 's/\(.\{2\}\)//' ${i}
        j=$(ls ${i} | cut -c 13-)
        mv ${i} listing${j}
        sleep 2
    # TODO: Remove Inline-Text-Listings, keep only Listing Boxes
    done
    rm listing_* > /dev/null 2>&1
    cd ..
fi
}


## Module: UPLOAD LISTINGS TO SERVER

function mod_upload_listings {

if [[ -d listings ]]; then

listing_part=$(pwd | grep -o '.*production/')
listing_full=${listing_part}"listings/magazin/"${issue_year}"/"
sw=$(grep -o '@SW:\( *.*\)' ${article} | cut -d':' -f2 | tr " " "_" | tr "[A-Z]" "[a-z]")

    if [[ -d ${listing_full}${issue_month}"/"${sw} ]]; then
    	cd listings
        mv -v listing* ${listing_full}${issue_month}"/"${sw}
        cd ..
        rmdir listings
    else
        echo "Create directory for listing"
        mkdir -vp ${listing_full}${issue_month}"/"${sw}
        mod_upload_listings
    fi
fi
}


## Module: MOVE FINISHED ARTICLES ##

function mod_move_finalized_folder {

	if [ -d ${target_folder} ]; then
	    #...if so, move all folders there
	    mv -i ${folder} ${target_folder}
	    echo "Move" ${folder} "to 2_checked."
	    echo -e "****\n"
	else
	    #...if not, mkdir folder
	    #mkdir ${target_folder}
        #mod_move_finalized_folder
        echo "Please create folder '2_checked' by hand and call '-m'-option again."
        exit 0
	fi
}


## Module: REPAIR XML ##

function mod_repair_xml {

article=article.xml

edi=$(grep -e '<section>Editorial</section>' ${article})
buecher=$(grep -e '<subject>Bücher</subject>' ${article})
perlsnap=$(grep -e '<subject>Perl-Snapshot</subject>' ${article})
delugdvd=$(grep -e '<kicker>In eigener Sache: DELUG-DVD</kicker>' ${article})

	if [ "${edi}" ] ; then
		sed -i 's/online access="free"/online access="restricted"/' ${article}
	    echo "Prepared XML file in ${folder} for Upload."
	fi

	if [ "${buecher}" ] || [ "${perlsnap}" ] || [ "${delugdvd}" ]; then
	    sed -i 's/online\ access="restricted"/online\ access="free"/' ${article}
	    echo "Prepared XML file in ${folder} for Upload."
	fi
}

#####   Main: "-c" - check for 'article.txt' #####
#       Checks, if export from Indesign worked and there is an 'article.txt' in every folder


function check {
    if [ -d ${exportpath} ]; then
        # List folders with leading digits
        for folder in $(ls -d ../[[:digit:]]*); do

	     if [[ -d ${folder} ]]; then
				# and dive into it
                cd ${folder}

				if [ -f ${article} ]; then
					continue
				else
					red=$(tput setaf 1)
					reset=$(tput sgr0)
					echo -e "Could not find file 'article.txt' in folder:" ${red}${folder}${reset}
					missing=true
                fi
            fi
        done
        if [ ${missing} ]; then
				red=$(tput setaf 1)
				reset=$(tput sgr0)
				echo -e ${red}"Please ask Layout to export the missing 'article.txt' file(s)."${reset}
			else
				green=$(tput setaf 2)
				reset=$(tput sgr0)
				echo -e ${green}"All 'article.txt' files seem to be in place. Please continue with 'lm_post_production -r'."${reset}
        fi
    else
		echo -e "You probably started this script from the wrong dir. Please read 'DESCRIPTION' in help section."
		exit 0
    fi
}

#####   Main: "-r" - repair txt-files #####
#       Repairs all kinds of bugs before conversion and shows result

function repair {

    # check, if location is your own subfolder in "1_export", for example "kki"
    sleep 2
    if [ -d ${exportpath} ]; then

        # make error.log for sf if non-existing
        if [ ! -f ${working_dir}/${error_log} ]; then
            touch ${working_dir}/${error_log}
            chmod u+x ${working_dir}/${error_log}
        fi

        ## Insert modules
        # List folders with leading digits and dive into it
        for folder in $(ls -d [[:digit:]]*); do
            if [ -d ${working_dir}/${folder} ]; then
                cd ${working_dir}/${folder}
                echo -e "\nNext article:"${folder}
                echo -e "================================"
                # convert to UTF-8
                convert_to_utf8

                # this module removes "Heft-DVD" boxes that make no sense online
                mod_warnings
                mod_remove_duplicate
                mod_insecurity_pic
                mod_remove_ads
                mod_replace_bookbox
                mod_prepare_ed_letter
                mod_prepare_pics_news_zut
                mod_repair_news_headline
                mod_repair_news_box
                mod_prepare_edi
                mod_repair_urls
                mod_repair_editor_abbrevation
                mod_repair_perl_video_box
                mod_repair_comments
		mod_prepare_tooltipps
		mod_tooltipps_stars
                mod_remove_boxes

                # convert back to ISO-8859-15
                convert_to_iso8859_15

                mod_html_check

                while true
                    do
                    read -p "Do you want to change something on the article and/or take a look at the 'error.log' now? [y/n]" error
                        case ${error} in
                        y)
                            echo "Error Log:"
                            cat ${working_dir}/${error_log} | more
                            echo -e "\n"
                            echo "Starting Editor..."
                            rm ${working_dir}/${error_log}
                            sleep 2
<<<<<<< HEAD
                            ${editor} ${article} > /dev/null 2>&1 &
=======
                            ${editor} ${article} 2>&1 &&
>>>>>>> b79c31051c16fc6c9c4306287a71994f796932b6
                            # Pass changes on TXT files to HTML files
                            ${bin_dir}/${satzfertig} -Hq ${article} ${article_html} 2>&1 &&

                            read -p "Move on to the next article? [y/n]" moveon
                                case ${moveon} in
                                y)
                                    break
                                    ;;
                                *)
                                    exit 0
                                    ;;
                                esac
                            break
                            ;;
                        *)
                            read -p "Move on to the next article? [y/n]" moveover
                                case ${moveover} in
                                y)
                                    rm ${working_dir}/${error_log}
                                    break
                                    ;;
                                *)
                                    exit 0
                                    ;;
                                esac
                            break
                            ;;
                        esac
                    done
                # go back in your subfolder, for example "kki"
                cd ..
            fi
        done
        echo -e "\nIf all articles look fine, you should now call 'lm_post_production -m' to extract listings and prepare files for a proper XML export.\n"
    else
	echo -e "You probably started this script from the wrong dir"
        exit 0
    fi
}


##### Main: "-m" - CONVERT LISTINGS AND MOVE FOLDERS #######

function make_listings {

    # check, if location is your own subfolder in "1_export", for example "kki"
    if [ -d ${exportpath} ]; then

        # make error.log for sf if non-existing
        if [ -f ${working_dir}/${error_log} ]; then
            touch ${working_dir}/${error_log}
            chmod a+x ${working_dir}/${error_log}
        fi

        ## Insert modules
        #
        # list folders and ls into it one by one
        echo -e "Script generates listings now if it finds some..."
        for folder in $(ls -d [[:digit:]]*); do
            if [ -d ${working_dir}/${folder} ]; then
                cd ${working_dir}/${folder}
                # after everything is fine with article.txt, start extracting the listings
                mod_extract_listing
                mod_upload_listings

                # go back in your subfolder, for example "kki"
                cd ..

                # check if $target_folder exists and move just finalized $folder there
                mod_move_finalized_folder

            fi
        done
    else
        echo "You need to create a subfolder in '1_export' and start this script from there."
        exit 0
    fi
}

##### Main -u: Prepare XML files for Upload
# CONVERT TXT TO XML AND CHANGE XML FILES

function upload {

    # check, if location is in "2_checked"
    if [ -d ${target_folder} ]; then
        ## Insert modules
        if [ "ls -A ${target_folder}" ]; then
            # change into '2_checked'
            cd ${target_folder}

            # show all folders an start conversion
            ls -d [0-9][0-9][0-9]*

            read -p "Convert all listed articles to XML - and repair XML files afterwards? [y/n]" yesyoucan
                case ${yesyoucan} in
                y | j)
                    . ${bin_dir}/convert2xml.sh -y ${issue_year} -i ${issue_month} -m LM
                    echo "Converted all articles to XML-files."
                    ;;
                *)
                    exit 0
                    ;;
                esac

        # repair things before conversion starts
        # list folders in '2_checked' and ls into it one by one
            for folder in $(ls -d [0-9][0-9][0-9]*); do
                if [ -d ${target_folder}/${folder} ]; then
                    cd ${target_folder}/${folder}
                    mod_repair_xml
                fi
            done
        else
            echo -e "No folder found in '2_checked'."
        fi
    else
        echo "This option only works if you call it from '1_export/<your_folder>'. It prepares existing XML files for the upload to our website."
        exit 0
    fi
}

function start {

    if [ "${1}" == "" ] || [ "${1}" == "-h" ] || [ "${1}" == "--help" ]; then
        get_help
    elif [ "${1}" == "-c" ] || [ "${1}" == "--check" ]; then
        check
    elif [ "${1}" == "-r" ] || [ "${1}" == "--repair" ]; then
        repair
    elif [ "${1}" == "-m" ] || [ "${1}" == "--make_listings" ]; then
        make_listings
    elif [ "${1}" == "-u" ] || [ "${1}" == "--upload" ]; then
        upload
    fi
}

start "${1}"
